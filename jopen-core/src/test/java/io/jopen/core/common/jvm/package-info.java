/**
 * https://zhuanlan.zhihu.com/p/34426768
 * JVM 内存结构:
 * 方法区: 存放的是对象的数据结构
 * <p>
 * 堆区: 描述Java对象的Class实例， Class对象封装了类在方法区内的数据结构，
 * 并且向Java程序员提供了访问方法区内的数据结构的接口。
 * <p>
 * 类的加载的最终产品是位于堆区中的Class对象
 * <p>
 * 类加载器: 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，
 * 如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）
 * 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
 * <p>
 * 加载class的方式:
 * 1 从本地系统中直接加载
 * 2 通过网络下载.class文件
 * 3 从zip，jar等归档文件中加载.class文件
 * 4 从专有数据库中提取.class文件
 * 5 将Java源文件动态编译为.class文件
 * <p>
 *  类的生命周期:
 *  其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。
 *  在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，
 *  而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定
 * （也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，
 *  因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。
 *
 * @author maxuefeng
 */
package io.jopen.core.common.jvm;